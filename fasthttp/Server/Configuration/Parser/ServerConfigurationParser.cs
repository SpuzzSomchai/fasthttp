using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FastHTTP.Server.Configuration.Parser
{
    /// <summary>
    /// A class to parse configuration files generated by fasthttp.
    /// </summary>
    public class ServerConfigurationParser
    {
        private string configPath;
        private string currentSName = "";
        private List<string> currentSectionBody = new List<string>();
        private int blockDepth = 0;
        private ConfigReadMode currentReadMode = ConfigReadMode.Normal;
        private int lineNumber = 0;

        public Dictionary<string, ConfigSection> DefinedSections { get; set; } = new Dictionary<string, ConfigSection>();
        public Dictionary<string, ConfigVariable> DefinedConstants { get; set; } = new Dictionary<string, ConfigVariable>();

        public static readonly string[] DISALLOWED_CHARACTERS = new string[] { ".", " ", "\"", "{", "}" };

        /// <summary>
        /// Creates a parser to parse configuration path.
        /// </summary>
        /// <param name="configPath">The file to parse</param>
        public ServerConfigurationParser(string configPath)
        {
            this.configPath = configPath;
            DefinedSections["__global__"] = new ConfigSection();
            DefinedConstants["FHTTPVERSION"] = new ConfigVariable() { DataType = ConfigVariableDataType.Integer, Name = "FHTTPVERSION", Value = 1 };
        }
        
        /// <summary>
        /// Defines a constant variable.
        /// </summary>
        /// <param name="name">The name of the constant to define</param>
        /// <param name="dataType">The data type to use</param>
        /// <param name="value">The value of the constant</param>
        /// <exception cref="ConstantAlreadyDefinedException"></exception>
        public void DefineConstant(string name, ConfigVariableDataType dataType, object value, int trackingLineNumber = -1)
        {
            CheckIdentifier(name, trackingLineNumber);
            if (DefinedConstants.ContainsKey(name)) throw new ConstantAlreadyDefinedException(name, trackingLineNumber);
            DefinedConstants[name] = new ConfigVariable()
            {
                Name = name,
                DataType = dataType,
                Value = value
            };
        }

        /// <summary>
        /// Parses the current file.
        /// </summary>
        public void Parse()
        {
            _Parse(File.ReadAllLines(configPath));
        }

        /// <summary>
        /// Parses the current file with a context.
        /// </summary>
        /// <param name="context">The context to use when parsing</param>
        public void Parse(string context)
        {
            _Parse(File.ReadAllLines(configPath), context);
        }

        /// <summary>
        /// Parses some text.
        /// </summary>
        /// <param name="contents">The contents to parse</param>
        public void Parse(string[] contents, string context = "__global__")
        {
            _Parse(contents, context);
        }

        /// <summary>
        /// Parse a variable from string.
        /// </summary>
        /// <param name="str">The variable string to parse</param>
        /// <returns>A variable constructed from the specified string</returns>
        private ConfigVariable ParseVar(string str)
        {
            string variableName = str.Substring(0, str.IndexOf(' '));
            string rightHandValue = str.Substring(str.IndexOf(' ') + 1).Trim();
            ConfigVariableDataType dataType = ConfigVariableDataType.Integer; // Assume integer at first
            if ((rightHandValue == "true") || (rightHandValue == "false"))
                return new ConfigVariable { DataType = ConfigVariableDataType.Boolean, Name = variableName, Value = bool.Parse(rightHandValue) };
            else if (rightHandValue == "null")
                return new ConfigVariable { DataType = ConfigVariableDataType.Null, Name = variableName, Value = new ConfigNullValue() };
            bool escapeMode = false; //Are we in escape char mode?
            bool literalTerminated = false;
            bool literalTypeFound = false;
            string resultantString = "";
            int resultantInt = 0;
            List<string> resultantList = new List<string>();
            for(int i=0;i<rightHandValue.Length;i++)
            {
                if (rightHandValue[i] == '\\')
                {
                    escapeMode = true;
                    continue;
                }
                else if ((rightHandValue[i] == '"') && (!escapeMode)) //Found a string quote
                {
                    if(!literalTypeFound)
                    {
                        literalTypeFound = true;
                        dataType = ConfigVariableDataType.String;
                        continue;
                    }
                    //This is a string terminator
                    literalTerminated = true;
                    break; //Exit the loop
                }
                switch (dataType)
                {
                    case ConfigVariableDataType.String:
                        if(escapeMode)
                        {
                            switch(rightHandValue[i])
                            {
                                case 't':
                                    resultantString += '\t';
                                    break;
                                case 'n':
                                    resultantString += '\n';
                                    break;
                                case 'a':
                                    resultantString += '\a';
                                    break;
                                case '"':
                                    resultantString += '"';
                                    break;
                            }
                        }
                        else resultantString += rightHandValue[i];
                        break;
                    case ConfigVariableDataType.Integer:
                        if (rightHandValue[i] == ' ') break; //Reached the end of literal
                        resultantString += rightHandValue[i]; //String like operation
                        break;
                }
                if (escapeMode)
                {
                    escapeMode = false;
                    continue;
                }
            }
            if ((dataType == ConfigVariableDataType.String) && (!literalTerminated)) throw new StringLiteralNotTerminatedException(variableName, lineNumber);
            if (dataType == ConfigVariableDataType.Integer) resultantInt = int.Parse(resultantString.Trim());
            return new ConfigVariable { DataType = dataType, Name = variableName, Value = new Func<object>(()=> {
                if (dataType == ConfigVariableDataType.Integer) return resultantInt;
                else return resultantString;
            })() }; //TODO optimize code here pls
        }

        /// <summary>
        /// Parse and evaluate text.
        /// </summary>
        /// <param name="data">The lines to parse</param>
        /// <param name="ctx">The context to run under (global is __global__)</param>
        private void _Parse(string[] data, string ctx = "__global__")
        {
            foreach(var rl in data)
            {
                lineNumber++;
                var ln = rl.Trim();
                if (ln == "") continue;
                else if (ln.StartsWith("//")) continue;
                foreach(var c in DefinedConstants)
                    if(currentReadMode != ConfigReadMode.MultiLineComment)
                        ln = ln.Replace("$" + c.Key + "$", c.Value.Value.ToString());
                foreach (var c in DefinedSections[ctx].Variables)
                    if (currentReadMode != ConfigReadMode.MultiLineComment)
                        ln = ln.Replace("$" + c.Key + "$", c.Value.Value.ToString());
                switch (currentReadMode)
                {
                    default:
                        //What read mode is this?!
                        break;
                    case ConfigReadMode.Normal:
                        if (ln.StartsWith("/*"))
                        {
                            currentReadMode = ConfigReadMode.MultiLineComment;
                            continue;
                        } else if(ln.StartsWith("const "))
                        {
                            // DEBUG only Console.WriteLine("Found const, lets parse it");
                            var v = ParseVar(ln.Substring(6).Trim());
                            DefineConstant(v.Name, v.DataType, v.Value, lineNumber);
                        } else if(ln.StartsWith("section "))
                        {
                            string sname = ln.Split(' ')[1].Trim();
                            if(sname.Contains(".")) throw new InvalidIdentifierNameException(lineNumber, sname);
                            currentReadMode = ConfigReadMode.SectionDef;
                            currentSName = sname;
                            blockDepth = 1;
                            continue;
                        } else if(ln.StartsWith("include "))
                        {
                            if (!ln.Contains("\"")) continue;
                            string fileName = ln.Split('"')[1].Trim();
                            if (!Path.IsPathRooted(fileName))
                                fileName = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(configPath)), fileName);
                            if (!File.Exists(fileName)) throw new IncludeNotFoundException(fileName, lineNumber);
                            var p = new ServerConfigurationParser(fileName);
                            p.DefinedConstants = DefinedConstants;
                            p.DefinedSections = DefinedSections;
                            p.Parse(ctx);
                        } else if(ln.Contains(" ")) //Probably a property
                        {
                            ConfigVariable var = ParseVar(ln.Trim());
                            DefinedSections[ctx].Variables[var.Name] = var;
                        }
                        break;
                    case ConfigReadMode.SectionDef:
                        if (ln.EndsWith("{")) blockDepth++;
                        else if (ln.EndsWith("}")) blockDepth--;
                        if(blockDepth == 0) //Finished searching section
                        {
                            var ctxedName = ctx + "." + currentSName;
                            DefinedSections[ctxedName] = new ConfigSection();
                            currentReadMode = ConfigReadMode.Normal;
                            var p = new ServerConfigurationParser(null);
                            p.DefinedConstants = DefinedConstants;
                            p.DefinedSections = DefinedSections;
                            p.lineNumber = lineNumber;
                            p.configPath = configPath;
                            p._Parse(currentSectionBody.ToArray(), ctxedName);
                            currentSName = "";
                            currentSectionBody.Clear();
                            continue;
                        }
                        currentSectionBody.Add(ln);
                        break;
                    case ConfigReadMode.MultiLineComment:
                        if (ln.EndsWith("*/"))
                        {
                            currentReadMode = ConfigReadMode.Normal;
                            continue;
                        }
                        break;
                }
            }
        }

        /// <summary>
        /// Returns a section object from the specified path.
        /// </summary>
        /// <param name="path">The path of the section to return.</param>
        /// <returns></returns>
        public ConfigSection GetSectionFromPath(string path)
        {
            string fullPath = "__global__." + path;
            if (!DefinedSections.ContainsKey(fullPath)) throw new SectionNotFoundException(path);
            return DefinedSections[fullPath];
        }

        /// <summary>
        /// Returns a variable for the specified path.
        /// </summary>
        /// <param name="path">The path of the variable to use.</param>
        /// <returns></returns>
        public ConfigVariable GetVariable(string path)
        {
            string sectionName = "__global__";
            string varName = "";
            if (path.IndexOf('.') == -1) varName = path;
            else
            {
                sectionName = "__global__." + path.Substring(0, path.LastIndexOf('.'));
                varName = path.Substring(path.LastIndexOf('.') + 1);
            }
            if (DefinedSections[sectionName].Variables.ContainsKey(varName))
                return DefinedSections[sectionName].Variables[varName];
            return null;
        }

        /// <summary>
        /// Returns an integer from the specified path.
        /// </summary>
        /// <param name="path">The path to use.</param>
        /// <returns></returns>
        public int GetInteger(string path)
        {
            ConfigVariable v = GetVariable(path);
            if ((v == null) || (v.DataType != ConfigVariableDataType.Integer)) return -1;
            return (int)v.Value;
        }

        /// <summary>
        /// Returns a string from the specified path.
        /// </summary>
        /// <param name="path">The path to use.</param>
        /// <returns></returns>
        public string GetString(string path)
        {
            ConfigVariable v = GetVariable(path);
            if ((v == null) || (v.DataType != ConfigVariableDataType.String)) return "";
            return (string)v.Value;
        }

        /// <summary>
        /// Returns a boolean from the specified path. Default value is false if not found.
        /// </summary>
        /// <param name="path">The path to use.</param>
        /// <returns></returns>
        public bool GetBool(string path)
        {
            ConfigVariable v = GetVariable(path);
            if ((v == null) || (v.DataType != ConfigVariableDataType.Boolean)) return false;
            return (bool)v.Value;
        }

        /// <summary>
        /// Checks if a given variable is given a null value.
        /// </summary>
        /// <param name="path">The path to use.</param>
        /// <returns></returns>
        public bool IsNull(string path)
        {
            ConfigVariable v = GetVariable(path);
            if ((v == null) || (v.DataType != ConfigVariableDataType.Null)) return false;
            return v.Value.GetType().IsAssignableFrom(typeof(ConfigNullValue));
        }

        /// <summary>
        /// Checks if a variable with the specified name exists.
        /// </summary>
        /// <param name="path">The path to use.</param>
        /// <returns></returns>
        public bool VariableExists(string path)
        {
            return GetVariable(path) != null;
        }

        /// <summary>
        /// Defines a variable with the specified name and value. If the variable already exists, it will be overwritten.
        /// </summary>
        /// <param name="name">The name of the variable.</param>
        /// <param name="value">The value of the variable. Only primitive types are supported, others are converted using ToString().</param>
        /// <param name="section">The section to place the variable in. Must be a valid section or a SectionNotFoundException will be thrown.</param>
        /// <exception cref="SectionNotFoundException"></exception>
        public void DefineVariable(string name, object value, string section = "")
        {
            ConfigVariable cv = new ConfigVariable() { Name = name };
            var valueType = value.GetType();
            if (valueType.IsAssignableFrom(typeof(string))) cv.DataType = ConfigVariableDataType.String;
            else if (valueType.IsAssignableFrom(typeof(int))) cv.DataType = ConfigVariableDataType.Integer;
            else if (valueType.IsAssignableFrom(typeof(bool))) cv.DataType = ConfigVariableDataType.Boolean;
            else if (valueType == null) cv.DataType = ConfigVariableDataType.Null;
            else cv.DataType = ConfigVariableDataType.Unknown;
            switch(cv.DataType)
            {
                default:
                    cv.Value = value;
                    break;
                case ConfigVariableDataType.Null:
                    cv.Value = new ConfigNullValue();
                    break;
                case ConfigVariableDataType.Unknown:
                    cv.DataType = ConfigVariableDataType.String;
                    cv.Value = value.ToString();
                    break;
            }
            AddVariable(cv, section);
        }

        /// <summary>
        /// Checks whether an identifier is valid
        /// </summary>
        /// <param name="id"></param>
        /// <exception cref="InvalidIdentifierNameException"></exception>
        private void CheckIdentifier(string id, int trackingLnNumber = -1)
        {
            foreach(var c in DISALLOWED_CHARACTERS)
                if (id.Contains(c)) throw new InvalidIdentifierNameException(trackingLnNumber, id);
        }

        /// <summary>
        /// Adds a variable to the specified section.
        /// </summary>
        /// <param name="variable">The variable object to add.</param>
        /// <param name="section">The section to add the variable to (leave empty for global section).</param>
        /// <exception cref="SectionNotFoundException"></exception>
        /// <exception cref="InvalidIdentifierNameException"></exception>
        public void AddVariable(ConfigVariable variable, string section = "")
        {
            CheckIdentifier(variable.Name);
            if (section == "") DefinedSections["__global__"].Variables[variable.Name] = variable;
            else
            {
                if (!DefinedSections.ContainsKey("__global__." + section)) throw new SectionNotFoundException(section);
                DefinedSections["__global__." + section].Variables[variable.Name] = variable;
            }
        }

        /// <summary>
        /// Displays a results table for the parser.
        /// </summary>
        /// <returns></returns>
        public void DisplayResultsTable()
        {
            StringBuilder contents = new StringBuilder();
            contents.AppendLine("Configuration Parser Results Table\n----------------------------------\n");
            contents.AppendLine("[Defined constants]\n");
            DefinedConstants.Keys.All((s) =>
            {
                contents.AppendLine(string.Format("  Constant Name: {0}, Constant Value: {1}", s, DefinedConstants[s].Value));
                return true;
            });
            contents.AppendLine("\n[Defined Sections]\n");
            DefinedSections.Keys.All((s) =>
            {
                contents.AppendLine(string.Format("  Section Name: {0}", s));
                DefinedSections[s].Variables.All((v) =>
                {
                    contents.AppendLine(string.Format("    {0} = {1}", v.Key, v.Value.Value));
                    return true;
                });
                return true;
            });
            Console.WriteLine(contents);
        }

        /// <summary>
        /// Returns all nested sections contained in a specified section.
        /// </summary>
        /// <param name="section">The section to look in.</param>
        /// <param name="recursive">A boolean specifying whether nested sections should be searched recursively.</param>
        /// <returns></returns>
        public string[] GetNestedSections(string section, bool recursive)
        {
            throw new NotImplementedException("oops not implemented sorry");
            //TODO implement this method pls
        }
    }
}
